/*
 * This source file was generated by the Gradle 'init' task
 */
package com.frc7028.physics.sim;

import static edu.wpi.first.units.Units.Degrees;
import static edu.wpi.first.units.Units.Radians;
import static org.junit.jupiter.api.Assertions.*;

import com.frc7028.physics.sim.BallisticPrecomputer.RobotState;
import edu.wpi.first.math.geometry.Rotation3d;
import edu.wpi.first.math.geometry.Translation2d;
import edu.wpi.first.math.geometry.Translation3d;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.function.Function;
import org.junit.jupiter.api.Test;

class AppTest {
  @Test
  void unitTest_ConvergeSolution() {

    Translation3d origin = new Translation3d(0, 0, 0);
    Region3d fieldBounds = new Region3d(origin, new Translation3d(10, 10, 5) // 10m x 10m x 5m cube
    );
    ArrayList<Region3d> obstacles = new ArrayList<>();
    obstacles.add(new Region3d(new Translation3d(4, 4, 0), new Translation3d(6, 6, 3)));
    ArrayList<Region3d> rejectRegions = new ArrayList<>();
    Region3d targetRegion = new Region3d(new Translation3d(9, 9, 0), new Translation3d(10, 10, 2));
    Region2d fieldPlane = new Region2d(new Translation2d(0, 0), new Translation2d(10, 10));
    System.out.println();
    System.out.println(targetRegion.center);
    FieldMetrics testFieldMetrics = new FieldMetrics(
        fieldPlane,
        fieldBounds,
        obstacles,
        rejectRegions,
        targetRegion,
        0.5 // starting height
    );
    SimulatorResolution simRes = new SimulatorResolution(
        Degrees.of(2), // 0.035 rad (~2°)
        0.5, // 0.5 m/s ← 500x bigger!
        0.1,
        0.1,
        0.2,
        2.0,
        20);
    IntegratorResolution intRes = new IntegratorResolution(
        0.01, // dt initial
        0.01, // epsilon
        1000 // max steps
    );
    BallisticEnvironmentProfile env = new BallisticEnvironmentProfile(
        0.1, // projectile mass (kg)
        -9.8, // gravity
        1.2, // air density
        0.1, // drag coefficient
        0.01, // cross-sectional area
        0.0, // magnus coefficient
        0.05 // radius
    );
    Function<Double, Rotation3d> spinFunction = speed -> new Rotation3d(); // no spin
    Function<BallisticPrecomputer.RobotState, BallisticPrecomputer.ShotParameters> guessShotFunction = state -> new BallisticPrecomputer.ShotParameters(
        Degrees.of(5),
        Degrees.of(10),
        50.0);
    RobotState testingRobotState = new RobotState(new Translation2d(1, 1), new Translation2d(-1, -1));

    App unitTest = new App(simRes, intRes, env, testFieldMetrics, spinFunction, guessShotFunction);
    StringBuffer cvs = new StringBuffer("x_1, y_1, z_1");

    // Test if integrator actually changes trajectory with parameter changes
    BallisticPrecomputer precomputer = unitTest.precomputer;
    RobotState state = testingRobotState;

    // Base trajectory length
    BallisticPrecomputer.ShotParameters baseShot = new BallisticPrecomputer.ShotParameters(
        Degrees.of(45),
        Degrees.of(10),
        15.0);
    precomputer.simulateBall(precomputer.projectileState, state, baseShot);
    int baseLength = precomputer.projectileState.trajectory.size();
    System.out.println("Base trajectory steps: " + baseLength);

    // Speed change - does trajectory length change?
    BallisticPrecomputer.ShotParameters fastShot = baseShot.stepSpeed(0.5);
    precomputer.simulateBall(precomputer.projectileState, state, fastShot);
    int fastLength = precomputer.projectileState.trajectory.size();
    System.out.println("Fast trajectory steps: " + fastLength);
    System.out.println("Steps changed? " + (baseLength != fastLength));

    unitTest.precomputer.convergeSolution(
        unitTest.precomputer.projectileState,
          testingRobotState,
          new BallisticPrecomputer.ShotParameters(Degrees.of(45), Radians.of(0.1), 5.0));

    unitTest.precomputer.projectileState.trajectory.forEach((Translation3d pos) -> {
      cvs.append(String.format("%.6f,%.6f,%.6f%n", pos.getX(), pos.getY(), pos.getZ()));
    });
    Path outputPath = Paths.get("trajectory.csv");
    try {
      Files.writeString(outputPath, cvs.toString());
    } catch (IOException e) {
    }
    System.out.println("FINISHED");
    // assertNotNull(convergedShot, "Shot should converge to a solution");
    // assertTrue(convergedShot.speed() > 0, "Speed should be positive");
    // System.out.println("Converged Shot:");
    // System.out.println("Yaw: " + convergedShot.yaw());
    // System.out.println("Pitch: " + convergedShot.pitch());
    // System.out.println("Speed: " + convergedShot.speed());

  }
}
